# General concept and overview:

- [Introduction Design Patterns(book-pdf)](../../../book/An%20Introduction%20to%20Design%20Patterns.pdf)
- [Design Patterns : Elements of Reusable Object-Oriented Software](../../../book/Design%20Patterns--Elements%20of%20Reusable%20Object-Oriented%20Software.pdf)
---
- > In general, design patterns prevent the repetition of code, which include everything, such as dependencies, code structure, contracts, names and specifications, etc., anything you can think of.

## What is Design Patterns :

In software engineering, a design pattern describes a relatively small, well-defined aspect (i.e. functionality) of a computer program in terms of how to write the code.
Using a pattern is intended to leverage an existing concept rather than re-inventing it. This can decrease the time to develop software and increase the quality of the resulting program.
Some consider using patterns to be best practice for software design. Some consider using design patterns as a structured approach to computer programming.

Conceptually, design pattern may be described as more specific than programming paradigm and less specific than algorithm.

> [source](https://en.wikipedia.org/wiki/Software_design_pattern)

## Parts :

1. Name
2. Problem
3. Solution
4. Consequences and trade-os of application

## The goals of a design pattern:

- Codify good design
- Distill and disseminate experience
- Aid to novices and experts alike
- Abstract how to think about design
- Give design structures explicit names
- Common vocabulary
- Reduced complexity
- Greater expressiveness
- Capture and preserve design information
- Articulate design decisions succinctly
- Improve documentation
- Facilitate restructuring/refactoring
- Patterns are interrelated
- Additional
- flexibility

In general, design patterns can speed up the development process, and the reuse of design patterns can prevent errors and bugs that are time-consuming to identify, and the use of design patterns makes the code more readable for developers. become another



## Patterns by type

### Creational
> 
Creational patterns are ones that create objects, rather than having to instantiate objects directly. This gives the program more flexibility in deciding which objects need to be created for a given case.

- Abstract factory groups object factories that have a common theme.
- Builder constructs complex objects by separating construction and representation.
- Factory method creates objects without specifying the exact class to create.
- Prototype creates objects by cloning an existing object.
- Singleton restricts object creation for a class to only one instance.


![](https://media.geeksforgeeks.org/wp-content/uploads/20240219154011/Creational-Design-Patterns.webp)


### Structural
Structural patterns concern class and object composition. They use inheritance to compose interfaces and define ways to compose objects to obtain new functionality.

- Adapter allows classes with incompatible interfaces to work together by wrapping its own interface around that of an already existing class.
- Bridge decouples an abstraction from its implementation so that the two can vary independently.
- Composite composes zero-or-more similar objects so that they can be manipulated as one object.
- Decorator dynamically adds/overrides behavior in an existing method of an object.
- Facade provides a simplified interface to a large body of code.
- Flyweight reduces the cost of creating and manipulating a large number of similar objects.
- Proxy provides a placeholder for another object to control access, reduce cost, and reduce complexity.

![](https://media.geeksforgeeks.org/wp-content/uploads/20240219161311/Structural-Design-Patterns-(1).webp)

### Behavioral
Most behavioral design patterns are specifically concerned with communication between objects.

- Chain of responsibility delegates commands to a chain of processing objects.
- Command creates objects that encapsulate actions and parameters.
- Interpreter implements a specialized language.
- Iterator accesses the elements of an object sequentially without exposing its underlying representation.
- Mediator allows loose coupling between classes by being the only class that has detailed knowledge of their methods.
- Memento provides the ability to restore an object to its previous state (undo).
- Observer is a publish/subscribe pattern, which allows a number of observer objects to see an event.
- State allows an object to alter its behavior when its internal state changes.
- Strategy allows one of a family of algorithms to be selected on-the-fly at runtime.
- Template method defines the skeleton of an algorithm as an abstract class, allowing its subclasses to provide concrete behavior.
- Visitor separates an algorithm from an object structure by moving the hierarchy of methods into one object.

![](https://media.geeksforgeeks.org/wp-content/uploads/20240213161457/behavioral-design-patterns-new.png)

### Concurrency 
- Active Object : Decouples method execution from method invocation that reside in their own thread of control. The goal is to introduce concurrency, by using asynchronous method invocation and a scheduler for handling requests.

- Balking: Only execute an action on an object when the object is in a particular state.

- Binding properties: Combining multiple observers to force properties in different objects to be synchronized or coordinated in some way.

- Compute kernel:The same calculation many times in parallel, differing by integer parameters used with non-branching pointer math into shared arrays, such as GPU-optimized Matrix multiplication or Convolutional neural network.

- Double-checked locking : Reduce the overhead of acquiring a lock by first testing the locking criterion (the 'lock hint') in an unsafe manner; only if that succeeds does the actual locking logic proceed.
Can be unsafe when implemented in some language/hardware combinations. It can therefore sometimes be considered an anti-pattern.
- Event-based asynchronous	Addresses problems with the asynchronous pattern that occur in multithreaded programs.
- Guarded suspension: Manages operations that require both a lock to be acquired and a precondition to be satisfied before the operation can be executed.	No	—
- Join	Join-pattern provides a way to write concurrent, parallel and distributed programs by message passing. Compared to the use of threads and locks, this is a high-level programming model.	No	—
- Lock	One thread puts a "lock" on a resource, preventing other threads from accessing or modifying it.[22]	No	PoEAA[14]
- Messaging design pattern (MDP)	Allows the interchange of information (i.e. messages) between components and applications.	No	—
- Monitor object	An object whose methods are subject to mutual exclusion, thus preventing multiple objects from erroneously trying to use it at the same time.	Yes	—
- Reactor	A reactor object provides an asynchronous interface to resources that must be handled synchronously.	Yes	—
- Read-write lock	Allows concurrent read access to an object, but requires exclusive access for write operations. An underlying semaphore might be used for writing, and a Copy-on-write mechanism may or may not be used.	No	—
- Scheduler	Explicitly control when threads may execute single-threaded code.	No	—
- Service handler pattern	For each request, a server spawns a dedicated client handler to handle a request.[23] Also referred to as thread-per-session.[24]	No	—
- Thread pool	A number of threads are created to perform a number of tasks, which are usually organized in a queue. Typically, there are many more tasks than threads. Can be considered a special case of the object pool pattern.	No	—
- Thread-specific storage	Static or "global" memory local to a thread.	Yes	—
- Safe Concurrency with Exclusive Ownership	Avoiding the need for runtime concurrent mechanisms, because exclusive ownership can be proven. This is a notable capability of the Rust language, but compile-time checking isn't the only means, a programmer will often manually design such patterns into code - omitting the use of locking mechanism because the programmer assesses that a given variable is never going to be concurrently accessed.

- CPU atomic operation	x86 and other CPU architectures support a range of atomic instructions that guarantee memory safety for modifying and accessing primitive values (integers). For example, two threads may both increment a counter safely. These capabilities can also be used to implement the mechanisms for other concurrency patterns as above. The C# language uses the Interlocked class for these capabilities.



### Better Understanding
![](https://media.geeksforgeeks.org/wp-content/uploads/20231229000629/Type-of-Design-Pattern.jpg)