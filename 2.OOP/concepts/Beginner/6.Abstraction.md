# Explanation:

Abstraction is a fundamental concept in computer science and software engineering, especially within the object-oriented programming paradigm Examples of this include:
the usage of abstract data types to separate usage from working representations of data within programs;

## [Rationale](<https://en.wikipedia.org/wiki/Abstraction_(computer_science)#Rationale>)

Computing mostly operates independently of the concrete world. The hardware implements a model of computation that is interchangeable with others. The software is structured in architectures to enable humans to create the enormous systems by concentrating on a few issues at a time. These architectures are made of specific choices of abstractions.

Language abstraction is a central form of abstraction in computing: new artificial languages are developed to express specific aspects of a system. Modeling languages help in planning. Computer languages can be processed with a computer. An example of this abstraction process is the generational development of programming language from the machine language to the assembly language and the high-level language. Each stage can be used as a stepping stone for the next stage. The language abstraction continues for example in scripting languages and domain-specific programming languages.

Within a programming language, some features let the programmer create new abstractions. These include subroutines, modules, polymorphism, and software components. Some other abstractions such as software design patterns and architectural styles remain invisible to a translator and operate only in the design of a system.

In object-oriented programming languages such as C++ or Java, the concept of abstraction itself has become a declarative statement - using the syntax function (parameters) = 0. (in C++) or the keywords abstract and interface (in Java).

> Note: In JavaScript, the concept of abstract, like Java or C++, is not a method or an expression
> These can allow the programmer to eliminate boilerplate code, abstract tedious function call sequences, implement new control flow structures, and implement domain-specific languages (DSL), which Domain specificity allows to express in concise and elegant ways.

# Summary:

Abstraction is one of the 4 pillars of object-oriented programming. The main purpose of abstraction is to hide the implementation details and show only necessary/necessary information. Simply put, it reduces complexity for the average user. It is mainly used to solve problems at the design level, mainly the conceptual part.

## Abstraction in real life

- Your car is a great example of abstraction. You can start the car by turning the key or pressing the start button. You don't need to know how the engine starts, what components your car has. The internal implementation and complex logic of the car is completely hidden from the user.

- We can heat our food in the microwave. We press a few buttons to set the timer and the type of food. Finally, we eat a warm and delicious meal. The internal details of the microwave are hidden from us. We have accessed the functionality in a very simple way.

## Understanding Abstraction in OOP

Abstraction, in the context of OOP, refers to the ability to hide complex implementation details and show only the necessary features of an object. This simplifies the interaction with objects, making programming more intuitive and efficient. It provides a clear separation between what an object does and how it achieves its functionality, fostering a higher level of understanding and collaboration among developers.

## Different Types of Abstraction

There are primarily two types of abstraction implemented in OOPs. One is data abstraction which pertains to abstracting data entities. The second one is process abstraction which hides the underlying implementation of a process. Letâ€™s take a quick peek into both of these.

## Types of Abstraction in OOP

1. **Data Abstraction**

Data abstraction is a fundamental concept in Object-Oriented Programming (OOP) that allows developers to manage complexity by focusing on essential features while hiding implementation details. At its core, data abstraction involves the creation of abstract data types that represent real-world entities or concepts.

Imagine you're working with a complex system like a car. In OOP, you would represent the car as an object with properties such as make, model, year, color, and methods such as start, stop, accelerate, and brake. However, you don't need to know the intricate details of how each of these methods is implemented within the car's internal systems. Instead, you interact with the car object using its interface (methods), abstracting away the complexities of its internal mechanisms.

For exapme (real life), let's say you decide to upgrade your car to a newer model. When you switch to the newer model, you're essentially interacting with a higher level of abstraction. You still have a car object, but now it might have additional features, improved performance, and better efficiency. However, as a user of the car object, you don't need to concern yourself with the specifics of how these improvements are implemented under the hood. You can simply use the car object's methods to perform tasks like driving, without worrying about the intricacies of its internal workings.

Data abstraction allows programmers to define abstract data types that encapsulate the essential properties and behaviors of real-world entities. By hiding the implementation details, data abstraction promotes modular design and code reusability. It also facilitates easier maintenance and extension of the system, as changes to the underlying implementation can be made without affecting other parts of the codebase.

Encapsulation, another key principle of OOP, complements data abstraction by bundling data and methods together within objects and restricting access to the internal state of objects. This not only enhances security but also promotes the principle of information hiding, which is essential for effective data abstraction.

In summary, data abstraction in OOP involves presenting a simplified view of complex data structures and operations, allowing developers to focus on essential features while hiding implementation details. This promotes modularity, code reusability, and ease of maintenance, making it a crucial concept in software development.

### Data Abstraction Example:

```javascript
// Define a Car class with properties and methods
class Car {
  constructor(make, model, year, color) {
    this.make = make;
    this.model = model;
    this.year = year;
    this.color = color;
    this.isStarted = false; // Represents whether the car is started or not
    this.currentSpeed = 0; // Represents the current speed of the car
  }

  // Method to start the car
  start() {
    this.isStarted = true;
    console.log("The car is started.");
  }

  // Method to stop the car
  stop() {
    this.isStarted = false;
    this.currentSpeed = 0; // Reset the current speed when the car stops
    console.log("The car is stopped.");
  }

  // Method to accelerate the car
  accelerate(speedIncrement) {
    if (this.isStarted) {
      this.currentSpeed += speedIncrement;
      console.log(
        `The car is accelerating. Current speed: ${this.currentSpeed} km/h`
      );
    } else {
      console.log("Cannot accelerate. Start the car first.");
    }
  }

  // Method to brake the car
  brake() {
    if (this.currentSpeed > 0) {
      this.currentSpeed -= 10; // Assuming a constant deceleration rate
      console.log(
        `The car is braking. Current speed: ${this.currentSpeed} km/h`
      );
    } else {
      console.log("The car is already stopped.");
    }
  }
}

// Create a new instance of the Car class
const myCar = new Car("Toyota", "Camry", 2022, "silver");

// Now, let's interact with the car object using its methods
myCar.start(); // Output: The car is started.
myCar.accelerate(50); // Output: The car is accelerating. Current speed: 50 km/h
myCar.brake(); // Output: The car is braking. Current speed: 40 km/h
myCar.stop(); // Output: The car is stopped.
```

2. **Process Abstraction**

Process abstraction in software development refers to hiding the underlying operational details of a process while exposing only the essential methods or actions that can be performed. This abstraction allows developers to work with abstract processes, utilizing hidden processes internally to achieve desired functionality.

Let's elaborate on the elevator example to understand process abstraction better:

When you're inside an elevator and you press a button to go to a desired floor, you're interacting with a high-level abstraction of the elevator's functionality. You simply press a button corresponding to the floor you want to reach, without needing to know the intricate details of how the elevator moves, accelerates, decelerates, and stops at the selected floor.

The process of going to the desired floor involves numerous complex operations within the elevator system, such as controlling the motor, managing the doors, monitoring the position of the elevator, and coordinating with other systems like sensors and safety mechanisms. However, as a user of the elevator, you're shielded from these low-level details. You only need to understand and utilize the abstract process of pressing a button to reach your destination.

In terms of software development, process abstraction allows developers to define methods or functions that represent high-level actions or operations without exposing the implementation details. For example, in an elevator control system implemented in software, you might have methods like `goToFloor(floorNumber)` or `openDoor()`, which abstract the process of elevator movement and door operation, respectively. These methods encapsulate the underlying complexities of elevator control, providing a simplified interface for interaction.

By employing process abstraction, developers can design systems that are easier to understand, maintain, and extend. It promotes modularity, code reusability, and separation of concerns, as different parts of the system can interact with abstract processes without being tightly coupled to the implementation details. Additionally, process abstraction enhances readability and reduces complexity, making software more comprehensible and manageable for both developers and users.

### Process Abstraction Example:

```javascript
// Define an Elevator class representing an elevator object
class Elevator {
  constructor(currentFloor) {
    this.currentFloor = currentFloor; // Current floor of the elevator
  }

  // Method to go to a specified floor
  goToFloor(floorNumber) {
    console.log(
      `Elevator moving from floor ${this.currentFloor} to floor ${floorNumber}`
    );
    this.currentFloor = floorNumber; // Update current floor
    console.log(`Elevator arrived at floor ${this.currentFloor}`);
  }

  // Method to simulate opening the elevator door
  openDoor() {
    console.log("Elevator door is opening...");
    // Simulate door opening time (setTimeout used for demonstration purposes)
    setTimeout(() => {
      console.log("Elevator door is open.");
    }, 1000); // Simulate door opening time
  }

  // Method to simulate closing the elevator door
  closeDoor() {
    console.log("Elevator door is closing...");
    // Simulate door closing time (setTimeout used for demonstration purposes)
    setTimeout(() => {
      console.log("Elevator door is closed.");
    }, 1000); // Simulate door closing time
  }
}

// Create a new instance of the Elevator class
const myElevator = new Elevator(1);

// Interact with the elevator using its abstracted methods
myElevator.goToFloor(5); // Output: Elevator moving from floor 1 to floor 5, Elevator arrived at floor 5
myElevator.openDoor(); // Output: Opening elevator door..., Elevator door opened.
myElevator.closeDoor(); // Output: Closing elevator door..., Elevator door closed.
```

In this example, we abstract the messaging service's behavior by defining a common interface (`MessagingService`) with the `sendMessage()` method. Concrete implementations (`SMSMessaging` and `EmailMessaging`) provide specific implementations for sending messages via SMS and email, respectively.

## Abstraction in JavaScript

Although JavaScript lacks native support for abstract classes and interfaces, developers can achieve abstraction by organizing their code to hide complex details and expose only essential features. Abstraction in JavaScript involves using prototypes, functions, and object-oriented patterns to encapsulate implementation details and provide clear interfaces for interaction.

### Advantages and Benefits of Abstraction:

- **Simplicity:** Abstraction simplifies complex systems, making them easier to understand and maintain.
- **Modularity:** Encapsulation of implementation details enhances modularity, allowing components to be modified or replaced without affecting other parts of the system.
- **Flexibility:** Abstraction promotes code reuse and extensibility, facilitating the development of scalable and adaptable software systems.

### Practical Examples in JavaScript:

#### Example 1: Shape Abstraction

```javascript
// Abstract Shape class
class Shape {
  constructor() {
    if (this.constructor === Shape) {
      throw new Error("Cannot instantiate abstract class");
    }
  }

  // Abstract method to calculate area
  calculateArea() {
    throw new Error("Method not implemented");
  }
}

// Concrete subclass Circle
class Circle extends Shape {
  constructor(radius) {
    super();
    this.radius = radius;
  }

  // Implementation of abstract method
  calculateArea() {
    return Math.PI * this.radius * this.radius;
  }
}

// Usage
const circle = new Circle(5);
console.log(circle.calculateArea()); // Outputs: 78.53981633974483
```

#### Example 2: Interface-like Abstraction

```javascript
// Interface-like abstraction for printers
class Printer {
  print() {
    throw new Error("Method not implemented");
  }
}

// Concrete implementation for inkjet printer
class InkjetPrinter extends Printer {
  print(content) {
    console.log(`Printing: ${content}`);
  }
}

// Usage
const printer = new InkjetPrinter();
printer.print("Hello, World!"); // Outputs: Printing: Hello, World!
```

### Data Abstraction in Detail:

Data abstraction involves encapsulating data within objects and exposing only essential features to the outside world. By abstracting the data representation, developers can manipulate objects without needing to know the internal details, promoting code simplicity and maintainability.

### Process Abstraction in Detail:

Process abstraction focuses on abstracting the behavior or processes of objects, allowing developers to interact with objects through clear interfaces without concerning themselves with the implementation details. Process abstraction is often achieved through interfaces or abstract methods, enabling polymorphic behavior and enhancing code flexibility.

### Abstraction vs. Concrete Implementation:

Abstraction emphasizes the high-level view of objects, hiding implementation details and exposing only essential features. In contrast, concrete implementation involves specifying the detailed workings of objects, including data representation and method implementations. By separating abstraction from concrete implementation, developers can design flexible and maintainable software systems.

## Best Practices for Using Abstraction in OOP:

- **Identify Essential Features:** Determine the essential features of objects and encapsulate them within clear interfaces or abstract classes.
- **Promote Encapsulation:** Encapsulate implementation details within objects to hide complexity and enhance modularity.
- **Strive for Reusability:** Design abstractions that promote code reuse and extensibility, allowing components to be used in various contexts without modification.
- **Document Interfaces:** Clearly document abstract classes, interfaces, and method contracts to guide developers in using and extending the abstraction effectively.

## Conclusion:

Abstraction is a powerful tool in object-oriented programming that simplifies complex systems, enhances modularity, and promotes code reuse and flexibility. By hiding implementation details and exposing clear interfaces, abstraction enables developers to design scalable and maintainable software systems that can adapt to changing requirements and environments. Understanding and effectively applying abstraction principles are essential skills for developers seeking to build robust and adaptable software solutions.
