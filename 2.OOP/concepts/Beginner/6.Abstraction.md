# Explanation:

Abstraction is a fundamental concept in computer science and software engineering, especially within the object-oriented programming paradigm Examples of this include:
the usage of abstract data types to separate usage from working representations of data within programs;

## [Rationale](<https://en.wikipedia.org/wiki/Abstraction_(computer_science)#Rationale>)

Computing mostly operates independently of the concrete world. The hardware implements a model of computation that is interchangeable with others. The software is structured in architectures to enable humans to create the enormous systems by concentrating on a few issues at a time. These architectures are made of specific choices of abstractions.

Language abstraction is a central form of abstraction in computing: new artificial languages are developed to express specific aspects of a system. Modeling languages help in planning. Computer languages can be processed with a computer. An example of this abstraction process is the generational development of programming language from the machine language to the assembly language and the high-level language. Each stage can be used as a stepping stone for the next stage. The language abstraction continues for example in scripting languages and domain-specific programming languages.

Within a programming language, some features let the programmer create new abstractions. These include subroutines, modules, polymorphism, and software components. Some other abstractions such as software design patterns and architectural styles remain invisible to a translator and operate only in the design of a system.

In object-oriented programming languages such as C++ or Java, the concept of abstraction itself has become a declarative statement - using the syntax function (parameters) = 0. (in C++) or the keywords abstract and interface (in Java).

> Note: In JavaScript, the concept of abstract, like Java or C++, is not a method or an expression
> These can allow the programmer to eliminate boilerplate code, abstract tedious function call sequences, implement new control flow structures, and implement domain-specific languages (DSL), which Domain specificity allows to express in concise and elegant ways.

# Summary:

Abstraction is one of the 4 pillars of object-oriented programming. The main purpose of abstraction is to hide the implementation details and show only necessary/necessary information. Simply put, it reduces complexity for the average user. It is mainly used to solve problems at the design level, mainly the conceptual part.

## Abstraction in real life

- Your car is a great example of abstraction. You can start the car by turning the key or pressing the start button. You don't need to know how the engine starts, what components your car has. The internal implementation and complex logic of the car is completely hidden from the user.

- We can heat our food in the microwave. We press a few buttons to set the timer and the type of food. Finally, we eat a warm and delicious meal. The internal details of the microwave are hidden from us. We have accessed the functionality in a very simple way.

## Understanding Abstraction in OOP

Abstraction, in the context of OOP, refers to the ability to hide complex implementation details and show only the necessary features of an object. This simplifies the interaction with objects, making programming more intuitive and efficient. It provides a clear separation between what an object does and how it achieves its functionality, fostering a higher level of understanding and collaboration among developers.

## Different Types of Abstraction

There are primarily two types of abstraction implemented in OOPs. One is data abstraction which pertains to abstracting data entities. The second one is process abstraction which hides the underlying implementation of a process. Letâ€™s take a quick peek into both of these.

## Types of Abstraction in OOP

1. **Data Abstraction**

![](https://journaldev.nyc3.cdn.digitaloceanspaces.com/2019/09/data-abstraction.png)

Data abstraction is a fundamental concept in Object-Oriented Programming (OOP) that allows developers to manage complexity by focusing on essential features while hiding implementation details. At its core, data abstraction involves the creation of abstract data types that represent real-world entities or concepts.

Imagine you're working with a complex system like a car. In OOP, you would represent the car as an object with properties such as make, model, year, color, and methods such as start, stop, accelerate, and brake. However, you don't need to know the intricate details of how each of these methods is implemented within the car's internal systems. Instead, you interact with the car object using its interface (methods), abstracting away the complexities of its internal mechanisms.

For exapme (real life), let's say you decide to upgrade your car to a newer model. When you switch to the newer model, you're essentially interacting with a higher level of abstraction. You still have a car object, but now it might have additional features, improved performance, and better efficiency. However, as a user of the car object, you don't need to concern yourself with the specifics of how these improvements are implemented under the hood. You can simply use the car object's methods to perform tasks like driving, without worrying about the intricacies of its internal workings.

Data abstraction allows programmers to define abstract data types that encapsulate the essential properties and behaviors of real-world entities. By hiding the implementation details, data abstraction promotes modular design and code reusability. It also facilitates easier maintenance and extension of the system, as changes to the underlying implementation can be made without affecting other parts of the codebase.

Encapsulation, another key principle of OOP, complements data abstraction by bundling data and methods together within objects and restricting access to the internal state of objects. This not only enhances security but also promotes the principle of information hiding, which is essential for effective data abstraction.

In summary, data abstraction in OOP involves presenting a simplified view of complex data structures and operations, allowing developers to focus on essential features while hiding implementation details. This promotes modularity, code reusability, and ease of maintenance, making it a crucial concept in software development.

### Data Abstraction Example:

```javascript
class User {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }

  // Method to get user details
  getUserDetails() {
    return `${this.name}, ${this.age} years old`;
  }
}

// Create a user object
const user = new User("Alice", 30);

// Accessing user details without knowing the internal implementation
console.log(user.getUserDetails()); // Outputs: Alice, 30 years old
```

In this example, we only expose essential user details (`name` and `age`) through the `getUserDetails()` method, while hiding the internal implementation details of the `User` class.

2. **Process Abstraction**

![](https://journaldev.nyc3.cdn.digitaloceanspaces.com/2019/09/process-abstraction.png)

Process abstraction focuses on abstracting the behavior or processes of an object. It allows developers to define the methods an object can perform without specifying how these methods are implemented. In languages like Java and C#, process abstraction is achieved through interfaces. Interfaces define a set of method signatures without providing the method implementations, enabling multiple classes to implement the same interface in different ways.

### Process Abstraction Example:

```javascript
// Abstract class representing a messaging service
class MessagingService {
  sendMessage(message) {
    throw new Error("Method not implemented");
  }
}

// Concrete implementation for SMS messaging
class SMSMessaging extends MessagingService {
  sendMessage(message) {
    console.log(`Sending SMS: ${message}`);
  }
}

// Concrete implementation for Email messaging
class EmailMessaging extends MessagingService {
  sendMessage(message) {
    console.log(`Sending Email: ${message}`);
  }
}

// Usage
const smsService = new SMSMessaging();
smsService.sendMessage("Hello via SMS"); // Outputs: Sending SMS: Hello via SMS

const emailService = new EmailMessaging();
emailService.sendMessage("Hello via Email"); // Outputs: Sending Email: Hello via Email
```

In this example, we abstract the messaging service's behavior by defining a common interface (`MessagingService`) with the `sendMessage()` method. Concrete implementations (`SMSMessaging` and `EmailMessaging`) provide specific implementations for sending messages via SMS and email, respectively.

## Abstraction in JavaScript

Although JavaScript lacks native support for abstract classes and interfaces, developers can achieve abstraction by organizing their code to hide complex details and expose only essential features. Abstraction in JavaScript involves using prototypes, functions, and object-oriented patterns to encapsulate implementation details and provide clear interfaces for interaction.

### Advantages and Benefits of Abstraction:

- **Simplicity:** Abstraction simplifies complex systems, making them easier to understand and maintain.
- **Modularity:** Encapsulation of implementation details enhances modularity, allowing components to be modified or replaced without affecting other parts of the system.
- **Flexibility:** Abstraction promotes code reuse and extensibility, facilitating the development of scalable and adaptable software systems.

### Practical Examples in JavaScript:

#### Example 1: Shape Abstraction

```javascript
// Abstract Shape class
class Shape {
  constructor() {
    if (this.constructor === Shape) {
      throw new Error("Cannot instantiate abstract class");
    }
  }

  // Abstract method to calculate area
  calculateArea() {
    throw new Error("Method not implemented");
  }
}

// Concrete subclass Circle
class Circle extends Shape {
  constructor(radius) {
    super();
    this.radius = radius;
  }

  // Implementation of abstract method
  calculateArea() {
    return Math.PI * this.radius * this.radius;
  }
}

// Usage
const circle = new Circle(5);
console.log(circle.calculateArea()); // Outputs: 78.53981633974483
```

#### Example 2: Interface-like Abstraction

```javascript
// Interface-like abstraction for printers
class Printer {
  print() {
    throw new Error("Method not implemented");
  }
}

// Concrete implementation for inkjet printer
class InkjetPrinter extends Printer {
  print(content) {
    console.log(`Printing: ${content}`);
  }
}

// Usage
const printer = new InkjetPrinter();
printer.print("Hello, World!"); // Outputs: Printing: Hello, World!
```

### Data Abstraction in Detail:

Data abstraction involves encapsulating data within objects and exposing only essential features to the outside world. By abstracting the data representation, developers can manipulate objects without needing to know the internal details, promoting code simplicity and maintainability.

### Process Abstraction in Detail:

Process abstraction focuses on abstracting the behavior or processes of objects, allowing developers to interact with objects through clear interfaces without concerning themselves with the implementation details. Process abstraction is often achieved through interfaces or abstract methods, enabling polymorphic behavior and enhancing code flexibility.

### Abstraction vs. Concrete Implementation:

Abstraction emphasizes the high-level view of objects, hiding implementation details and exposing only essential features. In contrast, concrete implementation involves specifying the detailed workings of objects, including data representation and method implementations. By separating abstraction from concrete implementation, developers can design flexible and maintainable software systems.

## Best Practices for Using Abstraction in OOP:

- **Identify Essential Features:** Determine the essential features of objects and encapsulate them within clear interfaces or abstract classes.
- **Promote Encapsulation:** Encapsulate implementation details within objects to hide complexity and enhance modularity.
- **Strive for Reusability:** Design abstractions that promote code reuse and extensibility, allowing components to be used in various contexts without modification.
- **Document Interfaces:** Clearly document abstract classes, interfaces, and method contracts to guide developers in using and extending the abstraction effectively.

## Conclusion:

Abstraction is a powerful tool in object-oriented programming that simplifies complex systems, enhances modularity, and promotes code reuse and flexibility. By hiding implementation details and exposing clear interfaces, abstraction enables developers to design scalable and maintainable software systems that can adapt to changing requirements and environments. Understanding and effectively applying abstraction principles are essential skills for developers seeking to build robust and adaptable software solutions.
