# Cohesion and Coupling: Two OO Design Principles

### What is OO design?

Object-Oriented (OO) design is a software development methodology based on the principles of object-oriented programming (OOP). It aims to structure software systems by modeling real-world entities as objects, each encapsulating both data and behavior. In OO design, a system is conceptualized as a collection of interacting objects, where each object represents a distinct entity or concept within the domain being modeled.

#### Core Principles of OO Design:

1. **[Encapsulation]**(https://dev.to/m__mdy__m/what-is-encapsulation-48b0)

2. **[Abstraction]**(https://dev.to/m__mdy__m/understanding-abstraction-in-oop-1abp)

3. **[Inheritance]**(https://dev.to/m__mdy__m/exploring-inheritance-in-object-oriented-programming-k0e)

4. **[Polymorphism]**(https://dev.to/m__mdy__m/polymorphism-in-javascript-3l84)

### Summary

**Cohesion** and **coupling** are two fundamental principles in Object-Oriented (OO) design that play a crucial role in creating robust and maintainable software systems.

**Cohesion** refers to the degree to which the elements within a module or class are related to each other and focused on a single task or responsibility. High cohesion suggests that the elements within a module work closely together to achieve a common purpose, resulting in more readable, understandable, and maintainable code. On the other hand, low cohesion indicates that the elements within a module may be unrelated or loosely connected, leading to code that is harder to comprehend and modify.

**Coupling**, on the other hand, refers to the degree of interdependence between modules or classes. Low coupling implies that modules or classes are loosely connected and can be modified independently without affecting each other, promoting modularity, reusability, and maintainability. High coupling suggests strong interdependencies between modules or classes, making it difficult to modify one component without impacting others, leading to a fragile and less adaptable system.

In OO design, achieving high cohesion and low coupling is essential for building scalable, maintainable, and extensible software systems. Designing classes and modules that are cohesive and loosely coupled promotes code that is easier to understand, test, and maintain, facilitating the evolution of software over time. By adhering to these principles, developers can create more robust, flexible, and resilient applications that meet the evolving needs of users and stakeholders.

### Better Understanding:

![](https://logicmojo.com/assets/dist/new_pages/images/coupling-and-cohesion.png)

## Coupling

Coupling is a fundamental concept in object-oriented design that refers to the degree of interdependence between software modules or classes. It measures how closely connected or intertwined two or more routines or modules are within a system. Coupling reflects the strength of relationships between modules and the extent to which changes in one module can affect other modules.

**summary**:

> Coupling is the degree of interdependence between software modules; a measure of how closely connected two routines or modules are; the strength of the relationships between modules.

**Types of Coupling**

1. **Low Coupling**: Low coupling implies minimal interactions between different components. This desirable characteristic in OOP promotes modularity and independence. Achieved by limiting the knowledge each class or module has of others and ensuring communication occurs through well-defined interfaces, low coupling facilitates easier maintenance, testing, and reuse of code.

2. **High Coupling**: High coupling denotes strong dependencies between components. When one component relies heavily on the internal details of another, changes in one component can cascade, affecting others and rendering the system fragile and difficult to maintain. High coupling often results in code that is challenging to understand, modify, and test.

### Tight Coupling

Tight coupling occurs when modules or classes are highly dependent on each other, resulting in direct and strong interconnections. In tightly coupled systems, changes to one module often necessitate corresponding modifications in other modules, leading to a cascade of updates across the codebase. Tight coupling makes the system less flexible and more challenging to maintain.

#### Characteristics of Tight Coupling:

1. **Direct Dependencies**: Tightly coupled components directly reference and rely on each other's implementation details, such as method calls, data structures, or variable access.

2. **High Interdependency**: Tight coupling results in a high level of interdependency between modules or classes, where modifications in one component frequently require changes in multiple other components.

3. **Limited Reusability**: Components tightly coupled to specific implementation details are challenging to reuse in other contexts or projects. This lack of flexibility restricts the potential for code reuse and increases development effort when integrating tightly coupled components into new systems.

#### Example:

Consider a simplified example of a `ShoppingCart` class that interacts with a `Product` class:

```javascript
class ShoppingCart {
  constructor() {
    this.items = [];
  }

  addItem(product) {
    this.items.push(product);
    product.updateStock(); // tightly coupled
  }
}

class Product {
  constructor(name, price, quantity) {
    this.name = name;
    this.price = price;
    this.quantity = quantity;
  }

  updateStock() {
    // logic to update stock
  }
}
```

In this example, the `ShoppingCart` class is tightly coupled to the `Product` class. When adding an item to the shopping cart using the `addItem` method, the `ShoppingCart` directly calls the `updateStock()` method of the `Product` class. This tight coupling means that any changes to the `Product` class, such as renaming the `updateStock` method or changing its parameters, would require corresponding modifications in the `ShoppingCart` class.

#### Advantages of Tight Coupling:

1. **Efficiency**: Tight coupling may lead to more efficient code execution in some cases, as direct interactions between components can reduce overhead associated with indirection or abstraction layers.

2. **Simplicity**: In tightly integrated systems with minimal change requirements, direct dependencies between components can simplify development by making the code easier to understand and maintain.

#### Disadvantages of Tight Coupling:

1. **Reduced Flexibility**: Tight coupling limits the system's flexibility and adaptability to changes, as modifications to one component often necessitate updates in multiple other components, increasing the risk of errors and regressions.

2. **Limited Reusability**: Tightly coupled components are challenging to reuse in different contexts or projects, as they are closely tied to specific implementation details, reducing the potential for code reuse and increasing development effort.

3. **Difficulty in Testing**: Testing becomes more complex in tightly coupled systems, as isolating and testing individual components becomes challenging due to their strong dependencies. This can hinder effective unit testing and increase the effort required for integration testing.

4. **Maintenance Challenges**: Maintaining tightly coupled systems is more labor-intensive, as changes in one part of the system often require modifications in multiple other parts. This increases the risk of introducing bugs and makes it harder to understand and modify the codebase over time.

5. **Scalability Issues**: Tightly coupled systems may struggle to accommodate changes in scope or requirements, making them less scalable. Adding new features or scaling the system may require significant refactoring or restructuring, leading to increased development time and complexity.

### Loose Coupling

Loose coupling describes a relationship between modules or classes where interactions are flexible, independent, and rely on well-defined interfaces or abstractions rather than direct dependencies on each other's implementations. This design approach reduces dependencies between components, promoting modularity, maintainability, and resilience to changes within the codebase.

#### Example:

```javascript
// Example of loose coupling:

class ShoppingCart {
  constructor(stockUpdater) {
    this.items = [];
    this.stockUpdater = stockUpdater;
  }

  addItem(item) {
    this.items.push(item);
    // loosely coupled via interface
    this.stockUpdater.update(item);
  }
}

class StockUpdater {
  update(item) {
    // update stock logic
  }
}
```

In this example, the `ShoppingCart` class is loosely coupled with the stock updating functionality through the `StockUpdater` interface. Instead of directly calling methods of the `Product` class, the `ShoppingCart` class delegates the responsibility of updating stock to a separate `StockUpdater` class. This loose coupling decouples the `ShoppingCart` class from the specific implementation of stock updating, promoting modularity and easier maintenance.

### Advantages of Loose Coupling:

1. **Modularity**: Loose coupling promotes modularity by isolating components, making it easier to understand and manage individual pieces of code.

2. **Flexibility**: Components can be replaced or modified without affecting other parts of the system, allowing for greater flexibility and adaptability to changes.

3. **Testability**: Loosely coupled components are easier to test in isolation, facilitating unit testing and improving overall code quality.

4. **Scalability**: Loose coupling enables scalability by allowing new components to be added or existing ones to be extended without disrupting the entire system's functionality.

5. **Maintainability**: Changes to one component have minimal impact on other components, reducing the risk of unintended side effects and simplifying maintenance efforts over time.

### Disadvantages of Loose Coupling:

1. **Increased Complexity**: Introducing abstractions and interfaces to achieve loose coupling can sometimes add complexity to the codebase, making it harder to understand and navigate.

2. **Performance Overhead**: Loose coupling may lead to performance overhead in some cases due to the need for additional layers of abstraction or communication between components.

3. **Initial Development Time**: Designing components with loose coupling may require more upfront planning and design effort compared to tightly coupled systems.

4. **Potential for Over-Abstraction**: Excessive use of loose coupling can lead to over-abstraction, making the codebase overly complex and difficult to maintain.

5. **Dependencies on Interfaces**: Loose coupling often relies on interfaces or abstract classes, which can introduce dependencies that need to be managed carefully to avoid introducing unintended dependencies or breaking changes.

### Comparison

| Aspect            | Tight Coupling                              | Loose Coupling                                        |
| ----------------- | ------------------------------------------- | ----------------------------------------------------- |
| Dependency        | Direct dependencies between modules/classes | Indirect dependencies through interfaces/abstractions |
| Impact of Changes | Changes in one module often affect others   | Changes in one module have minimal impact on others   |
| Flexibility       | Limited flexibility and modifiability       | Higher flexibility and modifiability                  |
| Encapsulation     | Reduced encapsulation and abstraction       | Encourages encapsulation and abstraction              |
| Testability       | Harder to test in isolation                 | Easier to test in isolation                           |
| Maintenance       | Maintenance is more challenging             | Maintenance is easier                                 |

### Conclusion

The design choice between tight coupling and loose coupling plays a crucial role in determining the overall architecture, maintainability, and scalability of a software system. While both approaches have their advantages and disadvantages, understanding their implications is essential for making informed design decisions. the choice between tight coupling and loose coupling depends on the specific requirements, trade-offs, and constraints of the software project. While tight coupling may be suitable for small, tightly integrated systems with minimal change requirements, loose coupling is often preferred for larger, more complex systems where flexibility, scalability, and maintainability are critical considerations.

## Cohesion

Cohesion in computer programming refers to the degree to which the elements within a module are related or belong together. It is a fundamental concept in software design that influences various aspects of software quality, such as maintainability, reusability, and understandability.

In computer programming, cohesion refers to the degree to which the elements inside a module belong together.In one sense, it is a measure of the strength of relationship between the methods and data of a class and some unifying purpose or concept served by that class.
Cohesion is an ordinal type of measurement and is usually described as “`high cohesion`” or “`low cohesion`”. Modules with high cohesion tend to be preferable, because high cohesion is associated with several desirable traits of software including robustness, reliability, reusability, and understandability. In contrast, low cohesion is associated with undesirable traits such as being difficult to maintain, test, reuse, or even understand.
**NOTE:**

> Cohesion is often contrasted with coupling. High cohesion often correlates with loose coupling, and vice versa.

**Summary:**
In computer programming, cohesion refers to the degree to which the elements inside a module belong together. In one sense, it is a measure of the strength of relationship between the methods and data of a class and some unifying purpose or concept served by that class.

## High cohesion

> When methods within a class share commonalities and serve similar purposes, the class is said to exhibit high cohesion. This concept plays a crucial role in enhancing code readability, reusability, and maintainability while keeping complexity manageable.

### Cohesion is Increased if:

1. **Common Functionalities:** When the functionalities embedded in a class, accessible through its methods, have significant commonalities or serve a unified purpose, cohesion is increased. This ensures that the class encapsulates a coherent set of operations.

2. **Small Number of Related Activities:** High cohesion is achieved when methods within a class carry out a limited number of closely related activities. By avoiding broad or unrelated sets of data, the class maintains focus and clarity in its responsibilities.

3. **Grouping of Related Methods:** Related methods should be logically grouped together within the class structure or in the same source file. This facilitates comprehensibility and makes it easier for developers to locate and understand the functionalities provided by the class.

### Advantages of High Cohesion:

1. **Reduced Module Complexity:** Highly cohesive modules are simpler, containing fewer operations. This reduction in complexity makes the codebase easier to understand and maintain.

2. **Increased System Maintainability:** High cohesion minimizes the impact of changes in the domain or requirements. Modifications to one module often require fewer changes in other modules, thus enhancing system maintainability.

3. **Enhanced Module Reusability:** With cohesive sets of operations provided by highly cohesive modules, application developers can easily identify and utilize components, increasing code reuse and promoting modular design practices.


### Example :

```javascript
// Example of a highly cohesive class for managing user authentication

class AuthManager {
  constructor() {
    // Initialize authentication-related variables
    this.loggedInUser = null;
    this.isAuthenticated = false;
  }

  // Method to handle user login
  login(username, password) {
    // Authenticate user logic here
    // Assume it sets this.loggedInUser and this.isAuthenticated upon successful login
  }

  // Method to handle user logout
  logout() {
    // Clear authentication-related variables
    this.loggedInUser = null;
    this.isAuthenticated = false;
  }

  // Method to check if user is logged in
  isLoggedIn() {
    return this.isAuthenticated;
  }

  // Method to retrieve current logged-in user
  getCurrentUser() {
    return this.loggedInUser;
  }

  // Method to reset user password
  resetPassword(username, newPassword) {
    // Reset password logic here
  }
}

// Usage of AuthManager class
const authManager = new AuthManager();

// Example usage
authManager.login('john_doe', 'password123');
console.log(authManager.isLoggedIn()); // Output: true
console.log(authManager.getCurrentUser()); // Output: { username: 'john_doe', ... }

authManager.logout();
console.log(authManager.isLoggedIn()); // Output: false
console.log(authManager.getCurrentUser()); // Output: null
```

In this example:

- The `AuthManager` class encapsulates authentication-related functionalities.
- Methods within the class (`login`, `logout`, `isLoggedIn`, `getCurrentUser`, `resetPassword`) are closely related to user authentication and management.
- Each method serves a specific aspect of authentication, such as login, logout, checking if a user is logged in, retrieving the current user, and resetting passwords.
- The class exhibits high cohesion because all methods are focused on a common purpose of user authentication and management.
- Related methods are grouped within the same class, promoting code organization and readability.



## Low cohesion

Low cohesion in programming occurs when the elements within a module lack a strong, unified purpose or have loosely related functionalities. This can lead to code that is difficult to understand, maintain, and reuse. Below are the characteristics and disadvantages of low cohesion:

### Characteristics of Low Cohesion:

1. **Diverse Functionalities:** Low cohesion is observed when the functionalities embedded in a class or module are diverse and unrelated. Methods within the class may serve different purposes, leading to confusion about the module's responsibility.

2. **Large Number of Unrelated Activities:** Modules with low cohesion tend to contain methods that perform a large number of unrelated activities. This results in a lack of clarity and focus, making it challenging to understand the module's purpose.

3. **Scattered Related Methods:** Related methods may be scattered across different classes or modules rather than being logically grouped together. This fragmentation hampers code organization and makes it difficult for developers to locate and understand the functionalities provided by the module.

### Disadvantages of Low Cohesion:

1. **Increased Module Complexity:** Low cohesion results in modules that are more complex, containing a wide range of unrelated functionalities. This complexity makes it harder to understand, maintain, and modify the codebase.

2. **Decreased System Maintainability:** Changes in one part of the codebase may have unintended consequences in other parts due to the lack of cohesion. This increases the risk of introducing bugs and errors during maintenance and evolution of the system.

3. **Reduced Module Reusability:** Modules with low cohesion are less likely to be reusable in other parts of the system or in different projects. The lack of a cohesive purpose makes it challenging for developers to identify and extract reusable components from the module.

### Example of Low Cohesion:

```javascript
// Example of a class with low cohesion

class UtilityFunctions {
  constructor() {
    // Initialize utility functions
  }

  // Method to calculate area of a rectangle
  calculateRectangleArea(length, width) {
    return length * width;
  }

  // Method to convert a string to uppercase
  convertToUppercase(str) {
    return str.toUpperCase();
  }

  // Method to generate a random number
  generateRandomNumber(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  // Method to validate email format
  validateEmail(email) {
    return /\S+@\S+\.\S+/.test(email);
  }
}

// Usage of UtilityFunctions class
const utils = new UtilityFunctions();

// Example usage
console.log(utils.calculateRectangleArea(5, 10)); // Output: 50
console.log(utils.convertToUppercase('hello')); // Output: HELLO
console.log(utils.generateRandomNumber(1, 100)); // Output: Random number between 1 and 100
console.log(utils.validateEmail('example@example.com')); // Output: true
```

In this example:

- The `UtilityFunctions` class contains a collection of methods that perform unrelated tasks such as calculating rectangle area, converting strings to uppercase, generating random numbers, and validating email addresses.
- These methods do not have a strong, cohesive purpose; they are arbitrary utility functions bundled together within the same class.
- The class exhibits low cohesion because its methods lack a common theme or purpose, leading to a codebase that is harder to understand and maintain.
- Related methods should ideally be grouped together in separate classes or modules to improve cohesion and maintainability.

### Types of Cohesion:

### Advantages of High Cohesion:

1. **Improved Understandability**: High cohesion enhances the clarity and readability of the code, making it easier for developers to comprehend and navigate.

2. **Simplified Maintenance**: Modules or classes with high cohesion are easier to maintain and modify, as each element has a clear purpose and relevance.

3. **Enhanced Reusability**: Cohesive modules or classes can be reused more effectively in different contexts, as their functionality is well-defined and focused.

4. **Reduced Complexity**: High cohesion reduces complexity by minimizing unnecessary dependencies and promoting a more streamlined design.

### Disadvantages of Low Cohesion:

1. **Decreased Understandability**: Low cohesion leads to code that is harder to understand and maintain, as the relationships between elements may be unclear or ambiguous.

2. **Increased Complexity**: Low cohesion often results in complex and tangled code, making it difficult to isolate and address issues.

3. **Reduced Maintainability**: Code with low cohesion is more prone to errors and bugs, as changes to one part of the code may have unintended consequences elsewhere.

4. **Limited Reusability**: Modules or classes with low cohesion are less reusable, as their functionality may be scattered or intertwined with unrelated tasks.

### Best Practices for Achieving High Cohesion:

1. **Single Responsibility Principle (SRP)**: Each module or class should have a single responsibility or reason to change, promoting high cohesion.

2. **Encapsulation**: Encapsulate related functionality within modules or classes, minimizing external dependencies and promoting cohesion.

3. **Abstraction**: Abstract common functionalities into separate modules or classes, promoting cohesive design and code reuse.

4. **Regular Refactoring**: Regularly refactor code to eliminate code smells and improve cohesion, ensuring that modules or classes remain focused and well-defined.

Certainly! Here's a general comparison between high cohesion and low cohesion:

| Aspect            | High Cohesion                                                                                | Low Cohesion                                                                                                                 |
| ----------------- | -------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------- |
| Understandability | Easier to understand due to focused and clear responsibilities within modules or classes     | Harder to understand as the relationships between elements may be unclear or ambiguous                                       |
| Maintenance       | Simplifies maintenance and modifications, as each element has a well-defined purpose         | Increases maintenance complexity, as changes may have unintended consequences and require more effort to isolate and address |
| Reusability       | Enhances reusability by promoting cohesive design and focused functionality                  | Limits reusability, as functionality may be scattered and intertwined with unrelated tasks                                   |
| Complexity        | Reduces complexity by minimizing unnecessary dependencies and promoting a streamlined design | Increases complexity, leading to tangled code and difficulty in isolating issues                                             |
| Stability         | Enhances stability by reducing the impact of changes within modules or classes               | Decreases stability, as changes may propagate unpredictably across the codebase                                              |
| Performance       | Generally leads to better performance due to more efficient and focused code                 | May impact performance negatively due to increased complexity and scattered functionality                                    |

### Conclusion:

High cohesion is essential for creating maintainable, understandable, and reusable software systems. It promotes clarity, simplicity, and stability by organizing code into cohesive units with clear responsibilities. On the other hand, low cohesion results in complex, hard-to-maintain code that is prone to errors and difficult to understand. Striving for high cohesion is a key principle in software design and development, contributing to the overall quality and longevity of the software product.

## Coupling Vs Cohesion

| Aspect          | Coupling                                                                                   | Cohesion                                                                                                                     |
| --------------- | ------------------------------------------------------------------------------------------ | ---------------------------------------------------------------------------------------------------------------------------- |
| Definition      | Describes relationships and dependencies among distinct modules or classes within a system | Measures how well the elements within a module or class are related and focused on a single purpose                          |
| Focus           | Relationship between modules/classes                                                       | Relationship within a module/class                                                                                           |
| Purpose         | Determines how modules/classes interact with each other                                    | Determines how closely related and focused the elements within a module/class are                                            |
| Types           | Tight coupling, loose coupling                                                             | Functional cohesion, sequential cohesion, communicational cohesion, procedural cohesion, temporal cohesion, logical cohesion |
| Impact          | Affects the flexibility and maintainability of the system                                  | Affects the understandability, maintainability, and reusability of the codebase                                              |
| Dependency      | Direct or indirect dependencies between modules/classes                                    | Relationship between elements within the same module/class                                                                   |
| Relationship    | Interdependence between modules/classes                                                    | Unity and thematic consistency within a module/class                                                                         |
| Degree of Unity | Reflects how intertwined or interdependent modules/classes are                             | Reflects how well elements within a module/class work together towards a common purpose                                      |

### Conclusion:

Coupling and cohesion are two fundamental concepts in software design that play crucial roles in determining the quality and maintainability of a system. While coupling focuses on the relationships and dependencies between modules or classes, cohesion emphasizes the internal unity and thematic consistency within a module or class. Striking a balance between appropriate coupling and high cohesion is essential for designing robust, scalable, and maintainable software systems.

## Best Practices in JavaScript

When applying the principles of cohesion and coupling in JavaScript, there are several best practices to follow to ensure that your codebase is well-organized, maintainable, and scalable:

1. **Modularization**: Divide your code into modules based on functionality, with each module focusing on a specific task or responsibility. This promotes high cohesion by grouping related functionalities together.

2. **Single Responsibility Principle (SRP)**: Ensure that each module, class, or function has a single responsibility and does only one thing. This enhances cohesion by keeping the code focused and easier to understand.

3. **Encapsulation**: Encapsulate related data and behavior within classes or modules, hiding internal details and exposing only necessary interfaces. This promotes loose coupling by reducing direct dependencies between components.

4. **Dependency Injection**: Use dependency injection to inject dependencies into modules or classes from external sources rather than creating them internally. This reduces tight coupling by decoupling components and making them more reusable and testable.

5. **Event-Driven Architecture**: Implement event-driven architecture to decouple components and enable communication through events and callbacks. This promotes loose coupling by allowing modules to interact without direct dependencies.

6. **Interfaces and Abstractions**: Define clear interfaces and abstractions for interacting with modules or classes, rather than relying on concrete implementations. This facilitates loose coupling by allowing components to interact at a higher level of abstraction.

7. **Avoiding Global State**: Minimize the use of global variables and state, as they increase coupling between different parts of the codebase. Instead, use local scope and pass data explicitly between modules to promote loose coupling.

8. **Regular Refactoring**: Regularly refactor your codebase to eliminate code smells, improve cohesion, and reduce coupling. This ensures that your code remains clean, maintainable, and adaptable to changing requirements.

9. **Unit Testing**: Write unit tests for your modules and classes to ensure that they behave as expected in isolation. This promotes loose coupling by enabling components to be tested independently of their dependencies.

10. **Code Reviews**: Conduct regular code reviews to identify and address cohesion and coupling issues early in the development process. This fosters collaboration and ensures that best practices are followed throughout the codebase.

## Conclusion

In conclusion, cohesion and coupling stand as pivotal principles in object-oriented programming (OOP) design, shaping the structure and functionality of software systems. Cohesion emphasizes the unity and purposefulness of elements within modules or classes, while coupling defines the relationships and dependencies between these modules or classes.

By adhering to best practices such as the Single Responsibility Principle (SRP), developers can ensure that each module or class has a clear, singular purpose, promoting high cohesion. This clarity enhances the understandability, maintainability, and reusability of code, making it easier to evolve and extend over time.

Additionally, leveraging techniques like dependency injection and event-driven architecture facilitates loose coupling between modules, reducing direct dependencies and promoting flexibility. Loose coupling enables modules to interact with greater independence, making the codebase more modular, adaptable, and resilient to changes.

In essence, by striving for high cohesion and loose coupling, developers can create software systems that are easier to understand, maintain, and evolve. These principles serve as guiding lights, steering the design and implementation of robust, scalable, and efficient software solutions in JavaScript and beyond.
