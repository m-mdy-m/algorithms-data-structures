# Cohesion and Coupling: Two OOP Design Principle

## Summary
In Object-Oriented Programming (OOP), the quality of a design is often judged by two key principles: cohesion and coupling. These principles serve as cornerstones for creating maintainable, extensible, and robust software systems. 

- **Cohesion** refers to the degree to which elements within a module or class are related and work together towards a common purpose. A highly cohesive module or class focuses on a single responsibility or functionality, making it easier to understand and maintain.

- **Coupling**, on the other hand, measures the degree of interdependence between modules or classes. Loose coupling implies that modules or classes are relatively independent and can be modified or replaced without affecting other parts of the system, promoting flexibility and reusability.

### Better Understanding:

![](https://logicmojo.com/assets/dist/new_pages/images/coupling-and-cohesion-example.png)

## Coupling

Coupling delineates the relationships and dependencies among distinct modules or classes within a system. It reflects how intertwined or interdependent these entities are. The spectrum of coupling spans from tight coupling, where modules rely heavily on one another, to loose coupling, where modules interact with greater flexibility and independence.

**Summary:**
> In object oriented design, coupling refers to the degree of direct knowledge that one element has of another. In other words, how often do changes in class A force related changes in class B.

### Tight Coupling

Tight coupling occurs when modules or classes are highly dependent on each other, often resulting in code that is difficult to maintain and modify. Changes in one module may require corresponding changes in another module, leading to a cascade of updates across the codebase. This coupling is characterized by direct dependencies and strong interconnections between modules.

#### Example:
```javascript
// Example of tight coupling:

class ShoppingCart {
  constructor() {
    this.items = [];
  }
  
  addItem(item) {
    this.items.push(item);
    // tightly coupled to Product class
    item.updateStock(); 
  }
}

class Product {
  constructor(name, price, quantity) {
    this.name = name;
    this.price = price;
    this.quantity = quantity;
  }
  
  updateStock() {
    // update stock logic
  }
}
```

In this example, the `ShoppingCart` class is tightly coupled to the `Product` class. When adding an item to the shopping cart, the `ShoppingCart` directly calls the `updateStock()` method of the `Product` class. This tight coupling means that any changes to the `Product` class may necessitate modifications in the `ShoppingCart` class, leading to a higher degree of dependency between them.

### Loose Coupling

Loose coupling occurs when modules or classes interact with each other in a more flexible and independent manner. It reduces dependencies between modules, making the codebase more modular, maintainable, and resilient to changes. Modules communicate through well-defined interfaces or abstractions, rather than directly depending on each other's implementations.

#### Example:
```javascript
// Example of loose coupling:

class ShoppingCart {
  constructor(stockUpdater) {
    this.items = [];
    this.stockUpdater = stockUpdater;
  }
  
  addItem(item) {
    this.items.push(item);
    // loosely coupled via interface
    this.stockUpdater.update(item); 
  }
}

class StockUpdater {
  update(item) {
    // update stock logic
  }
}
```

In this example, the `ShoppingCart` class is loosely coupled with the stock updating functionality through the `StockUpdater` interface. Instead of directly calling methods of the `Product` class, the `ShoppingCart` class delegates the responsibility of updating stock to a separate `StockUpdater` class. This loose coupling decouples the `ShoppingCart` class from the specific implementation of stock updating, promoting modularity and easier maintenance.



## Cohesion
Cohesion measures how well the elements within a module or class are related and focused on a single purpose. High cohesion results in modules or classes that are easier to understand, maintain, and reuse, as they have a clear and well-defined responsibility.

### Coupling Vs Cohesion
While coupling defines how modules or classes interact with each other, cohesion defines how well the elements within a module or class are organized and related. The goal is to minimize coupling and maximize cohesion, leading to more modular, flexible, and maintainable code.

## Example Real-world
In real-world scenarios, cohesion and coupling play crucial roles in various systems. For instance, in a car engine, each component (such as the pistons, crankshaft, and valves) exhibits high cohesion, focusing on specific tasks, while the overall system demonstrates loose coupling, allowing for easy replacement or modification of individual components.

### Example In JavaScript
Consider a JavaScript application where modules represent different functionalities, such as user authentication, data fetching, and UI rendering. By designing each module with high cohesion, focusing on a single responsibility, and minimizing dependencies between modules, developers can create a more modular and maintainable codebase.

## Best Practices in JavaScript
To promote high cohesion and loose coupling in JavaScript:

- **Single Responsibility Principle (SRP)**: Design modules or classes to have a single responsibility, making them more cohesive and easier to maintain.
- **Dependency Injection**: Use dependency injection to decouple modules and reduce their dependencies on specific implementations, promoting flexibility and testability.
- **Event-Driven Architecture**: Implement an event-driven architecture to loosely couple modules and enable communication without direct dependencies.

## Conclusion
Cohesion and coupling are fundamental principles in OOP design, guiding developers towards creating modular, maintainable, and resilient software systems. By striving for high cohesion and loose coupling, developers can enhance code quality, promote reusability, and simplify maintenance and evolution of software applications.