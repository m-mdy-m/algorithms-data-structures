
\chapter{Amortized Analysis}
\section{Introduction to Amortized Analysis}
\subsection{Motivation: Why Average Per-Operation Cost?}
\subsection{Amortized vs. Average-Case Analysis}
\subsection{When to Use Amortized Analysis}

\section{Aggregate Analysis}
\subsection{Definition and Methodology}
\subsection{Example: Dynamic Array (Vector) Resizing}
\subsection{Example: Binary Counter Increment}
\subsection{Example: Stack with Multipop}

\section{The Accounting Method}
\subsection{Conceptual Framework: Credits and Debits}
\subsection{Defining Amortized Costs}
\subsection{Example: Dynamic Array via Accounting}
\subsection{Example: Splay Trees (Introduction)}
\subsection{Ensuring Non-Negative Credit Balance}

\section{The Potential Method}
\subsection{Potential Functions: Definition and Intuition}
\subsection{Relating Amortized Cost to Actual Cost}
\subsection{Designing Good Potential Functions}
\subsection{Example: Dynamic Array via Potential Method}
\subsection{Example: Binary Counter via Potential Method}
\subsection{Example: Fibonacci Heaps (Overview)}

\section{Comparing the Three Methods}
\subsection{Strengths and Weaknesses}
\subsection{When to Choose Which Method}
\subsection{Equivalence of Methods (Informal Discussion)}

\section{Advanced Applications}
\subsection{Splay Trees: Full Analysis}
\subsubsection{Access, Insert, Delete Operations}
\subsubsection{Potential Function and Amortized $O(\log n)$}
\subsubsection{Balance Theorem}
\subsection{Fibonacci Heaps}
\subsubsection{Operations: Insert, Merge, Decrease-Key, Delete-Min}
\subsubsection{Potential Function and Amortized Costs}
\subsubsection{Applications to Dijkstra and Prim}
\subsection{Disjoint-Set Union (Union-Find)}
\subsubsection{Path Compression and Union by Rank}
\subsubsection{Inverse Ackermann Function}
\subsubsection{Amortized $O(\alpha(n))$ per Operation}

\section{Exercises}