\chapter*{Introduction}
\addcontentsline{toc}{chapter}{Introduction}

\lettrine{O}{pen up} \file{git.c} in the git source code. First thing you see:

\begin{lstlisting}[language=C]
int cmd_main(int argc, const char **argv)
{
    struct strvec args = STRVEC_INIT;
    const char *cmd;
    int done_help = 0;
\end{lstlisting}

Wait. \code{cmd\_main}? Not \code{main}?

That's weird. Every C program has \code{main}. Why is git different?

And \code{struct strvec args = STRVEC\_INIT}—what's that macro doing? Why not just allocate normally?

And \code{done\_help}—that's a strange name for a variable. What does it track?

These aren't just random choices. Each one solves a problem. Each one has a reason.

This book is about those reasons.

\section*{What You're Going To Read}

This is a walkthrough of git's internals from a software engineering perspective.

Not how to use git. How git is built.

We're going to look at:
\begin{itemize}
    \item The data model and why it's brilliant
    \item The codebase structure and how it's organized  
    \item The algorithms and their complexity
    \item The design patterns used throughout
    \item The performance tricks and optimizations
    \item The extension points and plugin system
    \item How it compares to other version control systems
\end{itemize}

\section*{What This Book Is Not}

This is not a git tutorial. I'm not teaching you commands.

This is not a complete reference. Git has over 2000 files. I'm covering the important parts.

This is not academic. I'll talk about algorithms and complexity, but I'm not writing proofs.

This is not perfect. I'm figuring this stuff out as I go. I'll make mistakes. That's fine.

\section*{Why Git?}

Because it's everywhere. You probably use it every day.

Because it's well-designed. The core model is elegant even though the command interface is messy.

Because it's mature. Git has been around since 2005. The codebase has evolved, been refactored, been optimized. You can learn from that evolution.

Because it's interesting. Git does things differently than other version control systems. Understanding why teaches you about software design.

\section*{Prerequisites}

You should know:
\begin{itemize}
    \item Basic programming (any language is fine)
    \item Basic git usage (add, commit, push, merge)
    \item Basic data structures (trees, graphs, hash tables)
\end{itemize}

You don't need to know:
\begin{itemize}
    \item C (I'll explain the tricky parts)
    \item Advanced git (internals, plumbing commands)
    \item Algorithm analysis (I'll teach what you need)
\end{itemize}

\section*{How To Read This}

Start with Part I if you want context. Skip it if you already know what version control is and why git was created.

Part II (architecture) and Part III (data model) are essential. Read those.

After that, jump around. Want to understand merge algorithms? Go to Part VI. Want to see design patterns? Part V. Interested in how pack files work? Part IV.

Code examples are real. They're from git's actual source code. Sometimes I'll simplify for clarity, but I'll tell you when I do.

\section*{What Makes Git Special?}

Most version control systems think about changes. "User X changed line 47 from A to B."

Git thinks about snapshots. "Here's what the entire project looked like at this moment."

That one decision—snapshots not deltas—changes everything. It makes branching cheap. It makes merging easier. It makes git fast.

But it creates problems too. How do you store thousands of snapshots without using infinite disk space? How do you transfer data efficiently? How do you handle merge conflicts?

Git solves these problems in interesting ways. We're going to look at how.

\section*{The Core Insight}

Everything in git is content-addressable.

Files aren't named "README.md". They're named by their SHA-1 hash. If two files have the same content, they have the same hash, so git only stores them once.

This sounds weird but it's powerful. It means git can tell if two things are the same by comparing hashes. It means deduplication is automatic. It means you can reference any object by its hash and git can verify it hasn't been corrupted.

The entire git data model follows from this insight.

\section*{A Note on C}

Git is written in C. Not modern C++ or Rust. Old school pointer-heavy manual-memory-management C.

Why? Because git was written in 2005 by kernel developers. C was what they knew. C is portable. C is fast. C gives you control.

Reading C code is useful even if you never write C. It teaches you what's really happening. No abstractions hiding the details. Just pointers and memory and syscalls.

I'll explain the confusing parts. You'll be fine.

\section*{Starting Point}

We're going to start with the basics. What is git? Why does it exist? What problems does it solve?

Then we'll look at the architecture. How is the codebase organized? Where are things?

Then the data model. This is the heart of git. Objects, hashes, the DAG.

Then we go deeper. Algorithms, patterns, performance, extensions.

By the end, you'll understand how git works. Not just "here's what this command does" but "here's how this command is implemented and why."

Let's start.

\clearpage