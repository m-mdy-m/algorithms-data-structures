\chapter*{Introduction}
\addcontentsline{toc}{chapter}{Introduction}

\lettrine{E}{very design} decision has a reason. Every data structure solves a problem. Every algorithm makes a trade-off.\\
When you look at mature software, you're seeing years of evolution. Hundreds of developers. Thousands of decisions. Some good, some less good, all made for specific reasons at specific times.\\
Git is like that. It's been around since 2005. It's used by millions. It's been optimized, refactored, extended. And understanding it teaches you about software engineering.\\

\section*{What You're Going To Learn}

This book walks through Git's internals from an engineering perspective.\\
Not how to use Git. How Git is built.\\
We'll look at the data model and why it's clever. The codebase structure and how it evolved. The algorithms and their complexity. The design patterns that keep appearing. The performance optimizations. How it all fits together.\\
And more importantly—why. Why these choices? What problems do they solve? What are the trade-offs?\\

\section*{What This Book Isn't}

This is not a Git tutorial. If you need to learn Git commands, read Pro Git or the official documentation.\\
This is not complete reference. Git has over 2000 files and hundreds of commands. I'm covering the important parts, the core insights, the interesting engineering.\\
This is not academic. I'll talk about algorithms and complexity, but I'm not writing proofs or formal specifications. This is practical engineering.\\
This is not flawless. I'll make mistakes. I'll miss things. That's fine. The goal is understanding, not perfection.

\section*{Why Git?}

Because you probably use it every day. Most developers do.\\
Because it's well-designed at its core. The data model is elegant even if the command interface is messy.\\
Because it's mature. Twenty years of evolution. You can learn from that evolution—what worked, what didn't, what got changed and why.\\
Because it does things differently. Most version control systems work one way. Git works another way. Understanding why teaches you about design choices.

\section*{Prerequisites}

You should know basic programming. Any language is fine. Concepts like variables, functions, data structures.\\
You should know basic Git usage. Add, commit, push, merge. Not expert level, just the basics.\\
You should know basic data structures. Trees, graphs, hash tables. Nothing fancy.\\
You don't need to know C deeply. I'll explain the important parts.\\
You don't need to know advanced Git internals. That's what this book teaches.\\
You don't need algorithm analysis background. I'll teach what matters.\\

\section*{How To Read This}

Start with Part I if you want historical context. Skip it if you already know about version control evolution and why Git was created.\\
Parts II and III are essential. They cover architecture and the data model. Read those.\\
After that, jump around based on your interests. Want to understand merging? Go to Part VI. Curious about performance? Part IV. Interested in patterns? Part V.\\
Code examples are simplified for clarity but accurate in concept. When I show code, I'll tell you if I've simplified it.\\

\section*{The Core Ideas}

Most version control systems think in terms of changes. They track what changed between versions. Git doesn't.\\
Git thinks in terms of snapshots. It stores the complete state of your project at each commit. Not the difference—the whole thing.\\
That one decision changes everything. It makes branching cheap. It makes merging easier. It makes Git fast. But it also creates challenges. How do you store thousands of snapshots efficiently? How do you transfer them over networks? How do you handle conflicts?\\
Git solves these problems in specific ways. We're going to look at how and why.\\

\section*{Content-Addressable Storage}

Everything in Git is identified by its content hash. Files aren't named by their path. They're named by their SHA-1 hash.\\
If two files have the same content, they have the same hash. Git only stores them once. Automatic deduplication.\\
This seems weird at first but it's powerful. Git can tell if two things are identical by comparing hashes. It can detect corruption by verifying hashes. It can reference any object by its hash.\\
The entire system builds on this idea.

\section*{Starting Point}

We'll start with foundations. What is version control? Why does Git exist? What problems does it solve?\\
Then architecture. How is the codebase organized? Where are things located?\\
Then the data model. This is the heart of Git. Objects, hashes, the DAG structure.\\
Then we go deeper. Storage, algorithms, patterns, performance.\\
By the end, you'll understand how Git works. Not just what commands do, but how they're implemented and why.

\section*{A Word on Engineering}

Good engineering isn't about being clever. It's about solving problems effectively.\\
Sometimes the best solution is simple. Sometimes it's complex because the problem is complex. Sometimes it's ugly because reality is messy.\\
Git has all of these. Simple elegant parts. Complex necessary parts. Ugly historical parts.\\
Learning to distinguish between them—to see which complexity is essential and which is accidental—that's what studying real systems teaches you.\\
Let's start.

\clearpage