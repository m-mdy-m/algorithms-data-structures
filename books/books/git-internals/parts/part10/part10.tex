\part{Advanced Engineering Concepts}
\label{part:advanced-concepts}

\begin{partintro}
Patterns, tricks, and techniques that appear throughout the codebase. How Git handles complexity, maintains performance, and stays extensible.
\end{partintro}

\chapter{Immutability and Its Consequences}
% Objects never change
% Caching implications
% Threading benefits
% Debugging advantages
% Refcounting simplification
% What can't be immutable

\chapter{Copy-on-Write Patterns}
% Where Git uses COW
% Forking objects
% Lazy copying
% Performance benefits
% Memory overhead

\chapter{Lazy Loading and Evaluation}
% Deferred operations
% On-demand parsing
% Commit graph generation
% Index loading
% Performance impact

\chapter{State Machines}
% Where Git uses state machines
% Parsing state
% Protocol state
% Merge state
% Implementation patterns

\chapter{Callback and Iterator Patterns}
% Function pointers in C
% Generic iteration
% Tree walking callbacks
% Ref iteration
% Type safety approaches

\chapter{Bitmap Indices}
% Reachability bitmaps
% EWAH compression
% Bitmap generation
% Bitmap selection
% Query optimization
% Space-time trade-offs

\chapter{Prefix Compression}
% Delta encoding
% Path compression in trees
% Packed refs
% Where else used
% Decompression cost

\chapter{Sparse Data Structures}
% Sparse file representation
% Sparse checkout implementation
% Cone mode vs legacy
% Pattern matching
% Performance optimization

\chapter{Atomic Operations}
% Where atomicity matters
% CAS operations
% Memory barriers
% Lock-free structures
% Platform differences

\chapter{Error Handling Strategies}
% Return codes
% die() and exit()
% Error propagation
% Resource cleanup
% Graceful degradation
% Error messages

\chapter{Extension and Plugin Architecture}
% Hooks system
% Custom merge drivers
% Diff drivers
% Clean/smudge filters
% Credential helpers
% How extensibility is achieved