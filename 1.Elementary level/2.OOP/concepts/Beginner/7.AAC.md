## Association

### Explanation
Association represents a relationship between two classes where each class has its own lifecycle, and there's no ownership involved. This is a loosely coupled relationship where objects of one class are aware of and can interact with objects of another class, but neither class "owns" the other.

### Example
Consider a `Teacher` and a `Student`. A `Teacher` can have multiple students, and a `Student` can have multiple teachers. Both `Teacher` and `Student` have their own independent lifecycles.

### Example in JavaScript

```javascript
// Association Example
class Teacher {
  teach(student) {
    console.log("Teaching...");
    student.learn();
  }
}

class Student {
  learn() {
    console.log("Learning...");
  }
}

const teacher = new Teacher();
const student = new Student();

teacher.teach(student);
```

### Pros and Cons
**Pros:**
- **Flexibility:** Classes can interact with each other without being tightly bound.
- **Reusability:** Both classes can be reused independently in other relationships.

**Cons:**
- **Lack of ownership:** There's no clear ownership of one class over the other, which can lead to ambiguity in code maintenance.

## Aggregation

### Explanation
Aggregation is a specialized form of association where one class contains references to other classes as part of its state. It represents a whole-part or part-of relationship where the part can exist independently of the whole.

### Example
A `Department` can contain multiple `Employee` objects. The `Employee` objects can exist independently of the `Department` and can be part of different departments.

### Example in JavaScript

```javascript
// Aggregation Example
class Department {
  constructor() {
    this.employees = [];
  }

  addEmployee(employee) {
    this.employees.push(employee);
  }
}

class Employee {
  work() {
    console.log("Working...");
  }
}

const department = new Department();
const employee1 = new Employee();
const employee2 = new Employee();

department.addEmployee(employee1);
department.addEmployee(employee2);
```

### Pros and Cons
**Pros:**
- **Code Reusability:** Both classes can exist independently and be reused.
- **Flexibility:** Objects can be added or removed from the aggregation without affecting the overall structure.

**Cons:**
- **Lifetime management:** The lifetime of the contained object can be independent of the container, leading to potential issues if not managed properly.

## Composition

### Explanation
Composition is a strong form of aggregation where one class contains other classes as part of its state, and the containing object manages the creation and lifetime of its parts. It's a "contains-a" relationship, where the parts cannot exist independently of the whole.

### Example
A `Car` class composed of `Engine`, `Wheels`, and `Chassis`. The parts cannot exist independently of the `Car`.

### Example in JavaScript

```javascript
class Car {
  constructor() {
    this.engine = new Engine();
    this.wheels = new Wheels();
    this.chassis = new Chassis();
  }
}

class Engine {
  start() {
    console.log("Engine starting...");
  }
}

class Wheels {
  roll() {
    console.log("Wheels rolling...");
  }
}

class Chassis {
  stabilityCheck() {
    console.log("Chassis stability check...");
  }
}

const myCar = new Car();
myCar.engine.start();
myCar.wheels.roll();
myCar.chassis.stabilityCheck();
```

### Pros and Cons
**Pros:**
- **Strong ownership:** The containing object fully controls the existence and lifetime of its parts, leading to clearer code and design.
- **Encapsulation:** The containing object encapsulates its parts, making it easier to manage complex systems.

**Cons:**
- **Tight coupling:** Changes to the containing object may have significant impacts on its parts, potentially making the code less flexible.

## Comparison

| Feature     | Association    | Aggregation    | Composition    |
| ----------- | -------------- | -------------- | -------------- |
| Ownership   | No ownership   | Part owner     | Full ownership |
| Flexibility | High           | High           | Low            |
| Coupling    | Loose coupling | Loose coupling | Tight coupling |
| Dependency  | Low            | Low            | High           |
| Reusability | High           | High           | Low            |

## Best Practices in JavaScript

- **Association:** Utilize event-driven programming or callback functions to establish loose associations between objects.
- **Aggregation:** Implement factory patterns or dependency injection to manage the creation and lifecycles of aggregated objects.
- **Composition:** Utilize composition over inheritance to build complex objects with clear ownership and encapsulation.

## Complete Example

Let's consider a more complex example to demonstrate all three relationships in a single scenario:

### Scenario
We have a school system where:
1. `Teacher` and `Student` have an association.
2. A `Department` aggregates `Teacher` objects.
3. A `School` is composed of `Department` objects.

### JavaScript Implementation

```javascript
// Association Example
class Teacher {
  teach(student) {
    console.log("Teaching...");
    student.learn();
  }
}

class Student {
  learn() {
    console.log("Learning...");
  }
}

// Aggregation Example
class Department {
  constructor(name) {
    this.name = name;
    this.teachers = [];
  }

  addTeacher(teacher) {
    this.teachers.push(teacher);
  }
}

// Composition Example
class School {
  constructor() {
    this.departments = [];
  }

  addDepartment(department) {
    this.departments.push(department);
  }
}

// Creating instances
const teacher1 = new Teacher();
const teacher2 = new Teacher();
const student = new Student();

const department1 = new Department('Math');
department1.addTeacher(teacher1);

const department2 = new Department('Science');
department2.addTeacher(teacher2);

const school = new School();
school.addDepartment(department1);
school.addDepartment(department2);

// Demonstrate Association
teacher1.teach(student);

// Output the school structure
console.log(school);
```

In this example:
- The `Teacher` and `Student` classes have an association.
- The `Department` class aggregates `Teacher` objects.
- The `School` class is composed of `Department` objects.